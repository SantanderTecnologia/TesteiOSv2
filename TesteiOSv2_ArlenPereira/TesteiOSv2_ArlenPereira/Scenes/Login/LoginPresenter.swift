//
//  LoginPresenter.swift
//  TesteiOSv2_ArlenPereira
//
//  Created by Arlen Ricardo Pereira on 28/01/20.
//  Copyright (c) 2020 Arlen Ricardo Pereira. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import CPF_CNPJ_Validator

protocol LoginPresentationLogic
{
    func presentLogin(response: LoginModel.LoginRequestModel.Response)
    func presentValidationLogin(response: LoginModel.ValidationLoginModel.Response)
}

class LoginPresenter: LoginPresentationLogic
{
    
    weak var viewController: LoginDisplayLogic?

    // MARK: - Function

    func presentLogin(response: LoginModel.LoginRequestModel.Response)
    {
        var dataResult: [LoginModel.LoginRequestModel.ViewModel.DisplayLogin] = []
        var codeResult: String = ""
        var msgResult: String = ""

        if !response.loginResponse.data!.isEmpty {
            for item in response.loginResponse.data! {
                dataResult.append(LoginModel.LoginRequestModel.ViewModel.DisplayLogin(userId: item.userId,
                                                                                      name: item.name,
                                                                                      bankAccount: item.bankAccount,
                                                                                      balance: item.balance,
                                                                                      code: item.code,
                                                                                      message: item.message)
            )}
        }
    
        if response.loginResponse.code != nil || response.loginResponse.message != nil {
            codeResult = response.loginResponse.code!
            msgResult = response.loginResponse.message!
            
            switch codeResult {
            case "-1003":
                msgResult = "NÃ£o foi possivel conectar com o servidor, tente mais tarde..."
                break
                
            default:
                break
            }
        }

        let viewModel = LoginModel.LoginRequestModel.ViewModel(data: dataResult, message: msgResult, code: codeResult)
        viewController?.displayLogin(viewModel: viewModel)
    }
    
    func presentValidationLogin(response: LoginModel.ValidationLoginModel.Response) {
        
        var isUsernameValid = false
        var isPasswordValid = false
        var errorMessageString: String = ""
        if !response.username.isEmpty {
            let usernameString = response.username
            if validateCPF(username: usernameString) || validateEmail(username: usernameString) {
                isUsernameValid = true
            } else {
                errorMessageString = "User Invalido, por favor informe o Email ou CFP no user."
            }
        }
        
        if !response.password.isEmpty {
            let passwordString = response.password
            if validatePassword(password: passwordString) {
                isPasswordValid = true
            } else {
                errorMessageString = "Password Invalido, por favor informe uma letra maiuscula, um numero e um caracter especial na senha."
            }
        }

        let viewModel = LoginModel.ValidationLoginModel.ViewModel(isUsernameValid: isUsernameValid, isPasswordValid: isPasswordValid, errorMessage: errorMessageString)
        viewController?.displayValidationLogin(viewModel: viewModel)
    }
    
    public func validateCPF(username: String) -> Bool {
        
        let isValidCPF = BooleanValidator().validate(cpf: username)
        
        return isValidCPF
    }
    
    public func validateEmail(username: String) -> Bool {
        let emailRegEx = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}"
        let trimmedString = username.trimmingCharacters(in: .whitespaces)
        let validateEmail = NSPredicate(format: "SELF MATCHES %@", emailRegEx)
        let isValidadeEmail = validateEmail.evaluate(with: trimmedString)
        return isValidadeEmail
    }
    
    public func validatePassword(password: String) -> Bool {
        let passUppercaseRegEx = ".*[A-Z]+.*"
        let trimmedString = password.trimmingCharacters(in: .whitespaces)
        let validateUppercasePassword = NSPredicate(format:"SELF MATCHES %@", passUppercaseRegEx)
        let isvalidateUppercasePass = validateUppercasePassword.evaluate(with: trimmedString)
        
        let passAlphanumericRegEx = ".*[0-9]+.*"
        let validateAlphanumericPassword = NSPredicate(format:"SELF MATCHES %@", passAlphanumericRegEx)
        let isvalidateAlphanumericPass = validateAlphanumericPassword.evaluate(with: trimmedString)
        
        let passSpecialCharRegEx = ".*[.*&^%$#@()/]+.*"
        let validateSpecialCharPassword = NSPredicate(format:"SELF MATCHES %@", passSpecialCharRegEx)
        let isvalidateSpecialCharPass = validateSpecialCharPassword.evaluate(with: trimmedString)

        return isvalidateUppercasePass && isvalidateAlphanumericPass && isvalidateSpecialCharPass
    }
}
