//
//  LoginInteractor.swift
//  TesteSantander
//
//  Created by Hugo Abolis Jordao on 13/06/19.
//  Copyright (c) 2019 Hugo Abolis Jordao. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol LoginBusinessLogic
{
    func logUserIn(request: Login.Fetch.Request)
    func checkSavedLogin()
}

protocol LoginDataStore
{
    var userData: Login.Fetch.UserData?{ get set }
}

class LoginInteractor: LoginBusinessLogic, LoginDataStore
{
    var presenter: LoginPresentationLogic?
    var worker = LoginWorker()
    var userData: Login.Fetch.UserData?
    var userSavedData: Login.Fetch.UserLoginData?
    
    // MARK: Do something
    
    func logUserIn(request: Login.Fetch.Request)
    {
        let user = request.data["user"]
        let password = request.data["password"]
        
        if let error = validateData(user: user, pass: password){
            var response = Login.Fetch.Response(userAccount: nil, error: nil)
            response.error = Login.Fetch.ErrorData(code: 0, message: error)
            presenter?.presentLoginAttempt(response: response)
            return
        }
        
        worker.login(user: user!, password: password!){ response in
            self.userData = response?.userAccount
            self.presenter?.presentLoginAttempt(response: response)
            if response != nil || response?.error?.message == nil{
                _ = self.saveLoginData(loginData: Login.Fetch.UserLoginData(user: user, password: password))
            }
        }
    }
    func validateData(user: String?, pass: String?) -> String?{
        
        if user == nil || user == "" || pass == nil || user == ""{
            return "Ambos os campos precisam ser preenchidos."
        }
        
        if !(user!.contains("@") && user!.contains(".")){//It's not a email
            let CPF = user!
                .components(separatedBy:CharacterSet.decimalDigits.inverted)
                .joined(separator: "")
            if CPF.count != 11{
                return "O campo user precisa ser uma email ou um CPF"
            }
        }
        
        let hasAlphanumerics = pass!.rangeOfCharacter(from: CharacterSet.alphanumerics)
        let hasUpperCase = pass!.rangeOfCharacter(from: CharacterSet.uppercaseLetters)
        let hasSpecialChar = pass!.rangeOfCharacter(from: CharacterSet.punctuationCharacters)
        
        if hasUpperCase == nil || hasSpecialChar == nil || hasAlphanumerics == nil {
            return "A senha precisa ter pelo menos uma letra maiuscula, um caracter especial e um caracter alfanumÃ©rico"
        }
        
        return nil
    }
    
    func checkSavedLogin(){
        let savedEmailItem = KeychainService.loadPassword(service: Constants.keyChainServiceName, account: Constants.savedEmail)
        let savedPassItem = KeychainService.loadPassword(service: Constants.keyChainServiceName, account: Constants.savedPass)
        
        if savedEmailItem.1 == errSecSuccess && savedPassItem.1 == errSecSuccess{
            presenter?.presentSavedLogin(loginData: Login.Fetch.UserLoginData(user: savedEmailItem.0, password: savedPassItem.0))
        }
    }
    
    func saveLoginData(loginData: Login.Fetch.UserLoginData) -> Bool{
        var statusEmail = KeychainService.savePassword(service: Constants.keyChainServiceName, account: Constants.savedEmail, data: loginData.user ?? "")
        if statusEmail == errSecDuplicateItem{
            statusEmail = KeychainService.updatePassword(service: Constants.keyChainServiceName, account: Constants.savedEmail, data: loginData.user ?? "")
        }
        
        var statusPass = KeychainService.savePassword(service: Constants.keyChainServiceName, account: Constants.savedPass, data: loginData.password ?? "")
        if statusPass == errSecDuplicateItem{
            statusPass = KeychainService.updatePassword(service: Constants.keyChainServiceName, account: Constants.savedPass, data: loginData.password ?? "")
        }
        return statusEmail == errSecSuccess && statusEmail == errSecSuccess
    }
    
}
